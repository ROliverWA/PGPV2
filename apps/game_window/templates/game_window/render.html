{% extends 'game_window/game.html' %}
{% load staticfiles %}
{%block script %}

<script>
    var manager = new THREE.LoadingManager();
    var GameRoom = {{ game_id_json }};
    var GameSocket = new WebSocket(
        'ws://' + window.location.host +
        '/ws/game/' + GameRoom + '/');

    GameSocket.addEventListener('open', function (e) {
        var user = "{{ request.user }}";
    })


    GameSocket.onmessage = function (e) {
        var data = JSON.parse(e.data);
        if (data['position'] != 'NULL') {
            console.log(data)
        }
    };

    GameSocket.onclose = function (e) {
        console.error('Chat socket closed unexpectedly');
    };


    var scene
    var camera,
        renderer,
        mesh;
    var level;
    var txloader = new THREE.TextureLoader();
    var meshFloor;
    var keyboard = {};
    var player = {
        height: 1.8,
        speed: 0.2,
        turnSpeed: Math.PI * 0.02
    };
    var clock = new THREE.Clock();

    var playerarray = []
    var players = JSON.parse("{{ players|escapejs }}")
    for (x in players) {
        playerarray.push(players[x]['fields']['user'])
    }

    tarray={
        1: "grass.png",
        2: "dirt.jpg",
        3: "startfinish.jpg",
        4: "grass.png",
        5: "dirt.jpg",
        6: "fence",
    }
    modelpath = {
        6: ["Zaun",1,"{% static '/game_window/images/models/fence/' %}"],
        5: ["grass_lowfbx",.1,"{% static '/game_window/images/models/tallgrass/' %}"],
        4: ["Treefbx",.03,"{% static '/game_window/images/models/tree/' %}"],
        0: ["",.3,"{% static '/game_window/images/bulby/' %}"],
    }
    worldArray = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,2,2,2,2,2,2,2,5,2,2,2,2,2,2,2,2,2,2,2,1],
        [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
        [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
        [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
        [1,5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
        [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
        [1,2,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,2,1],
        [1,3,1,1,1,1,1,1,1,4,4,4,1,1,1,1,1,1,1,2,1],
        [1,2,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,2,1],
        [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
        [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5,1],
        [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
        [1,5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
        [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
        [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
        [1,2,2,2,2,2,2,5,2,2,2,2,2,5,2,2,2,2,2,2,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    ]
    function buildWorld() {
        var x = 0;
        var y = 0;
        for(var i =0;i<worldArray.length;i++){
            for(var j=0;j<worldArray[i].length; j++){
                if (worldArray[i][j] > 3){
                    addPlane(tarray[worldArray[i][j]],txloader,x,y);
                    addModel('scene.gltf',x,y,modelpath[worldArray[i][j]][0],modelpath[worldArray[i][j]][1],modelpath[worldArray[i][j]][2]);
                    console.log(modelpath[worldArray[i][j]][2])
                    x += 20;
                } else {
                    addPlane(tarray[worldArray[i][j]],txloader,x,y);
                    x += 20;
                }
            }
            x = 0;
            y += 20;
        }



    }
    function loadModels() {
        const loader = new THREE.GLTFLoader();

        const onLoad = (gltf, position, id) => {
            const model = gltf.scene.children[0].children[0].children[0].children[0];
            model.position.copy(position);
            model.name = "player-" + id
            model.rotation.x -= Math.PI / 2;
            model.rotation.z -= Math.PI / 2;
            model.scale.set(0.3, 0.3, 0.3);
            scene.add(model);
        };
        ModelCount = 1

        var inter = setInterval(function () {
            if (ModelCount <= playerarray.length) {
                let playerpos = new THREE.Vector3(10, 0, 10);
                loader.setPath("{% static '/game_window/images/bulby/'%}" + ModelCount + "/")
                loader.load('scene.gltf', gltf => onLoad(gltf, playerpos, playerarray[ModelCount - 2]))
                ModelCount++
            }
            else {
                var interval2 = setInterval(function () {
                    if (ModelCount < playerarray.length + 2) {

                        activeplayer = scene.getObjectByName("player-{{ request.user.id }}")
                        camera = getCamera()
                        //activeplayer.add(camera)

                        ModelCount++
                    } else {
                        animate()

                        clearInterval(inter)
                        clearInterval(interval2)

                    }
                }, 400)
            }
        }, 500)
    }

    function addModel(model, x, y, objname, scale, path) {
        Modelloader = new THREE.GLTFLoader();
        Modelloader.setPath(path)
        Modelloader.load(model, function (gltf) {
            
            newobj = gltf.scene.getObjectByName(objname);
            console.log(gltf)
            newobj.position.x = x;
            newobj.position.y = y;
            newobj.scale.set(scale, scale, scale)
            meshFloor.add(newobj)
        })
    }
    function addPlane(texture,loader = txloader,x,y) {
        loader.setPath("{% static '/game_window/images/textures/'%}")
        var texture = loader.load(texture);
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(10, 10);
        var material = new THREE.MeshBasicMaterial({
            map: texture, side: THREE.DoubleSide
        });
        var geometry = new THREE.PlaneGeometry(20, 20, 20, 20);
        var plane = new THREE.Mesh(geometry, material);
        plane.position.z = .1;
        plane.position.x = x;
        plane.position.y = y;
        //plane.rotation.x = Math.PI / 2;
        meshFloor.add(plane);
    }
    function getCamera() {
        var aspectRatio = window.innerWidth / window.innerHeight;
        var camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
        camera.position.set(0, 150, 400);
        camera.lookAt(scene.position);
        return camera;
    }

    function moveCamera() {
        var relativeCameraOffset = new THREE.Vector3(-25, 0, 9);
        var cameraOffset = relativeCameraOffset.applyMatrix4(activeplayer.matrixWorld);
        camera.position.x = cameraOffset.x;
        camera.position.y = cameraOffset.y;
        camera.position.z = cameraOffset.z;
        camera.lookAt(activeplayer.position);
    }

    function init() {
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(1280, 720);
        document.body.appendChild(renderer.domElement);

        scene = new THREE.Scene();
        var light = new THREE.SpotLight(0xF9FCFF);
        light.position.set(0, 1000, 0);
        scene.add(light);

        meshFloor = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100, 100, 100),
            new THREE.MeshBasicMaterial({ color: 0xFF004A })//, wireframe: USE_WIREFRAME })
        );
        meshFloor.rotation.x -= Math.PI / 2; // Rotate the floor 90 degrees
        scene.add(meshFloor);
        buildWorld();
        loadModels();
        
    };

    function movePlayer() {
        var delta = clock.getDelta();
        var moveDistance = 20 * delta;
        var rotateAngle = Math.PI / 2 * delta;
        if (keyboard[87]) { // W 
            activeplayer.translateX(moveDistance)
            
        }
        if (keyboard[83]) { // S key

            activeplayer.translateX(-moveDistance);
        }

        var rotation_matrix = new THREE.Matrix4().identity();
        if (keyboard[65]) { // A keyad

            activeplayer.rotateOnAxis(new THREE.Vector3(0, 0, 1), rotateAngle);
            camera.rotation.z -= player.turnSpeed;
        }
        if (keyboard[68]) { // D key

            activeplayer.rotateOnAxis(new THREE.Vector3(0, 0, 1), -rotateAngle);
            camera.rotation.z += player.turnSpeed;
        }

        // Keyboard turn inputs
        if (keyboard[37]) { // left arrow key
            camera.rotation.y -= player.turnSpeed;
        }
        if (keyboard[39]) { // right arrow key
            camera.rotation.y += player.turnSpeed;
        }
        var pos = [activeplayer.position.x,activeplayer.position.y,"{{request.user.id}}"]
        // GameSocket.send(JSON.stringify({      
        //         'position': pos
        //     }));
    }
    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
        movePlayer()
        moveCamera()
    }

    function keyDown(event) {
        keyboard[event.keyCode] = true;
    }

    function keyUp(event) {
        keyboard[event.keyCode] = false;
    }

    window.addEventListener('keydown', keyDown);
    window.addEventListener('keyup', keyUp);
    window.onload = init;

</script>
{% endblock script %}